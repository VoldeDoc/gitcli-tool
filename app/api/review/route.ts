import { type NextRequest, NextResponse } from "next/server"
import { analyzeCode } from "@/lib/amazon-q"
import { fetchPullRequests, postCommentToPR } from "@/lib/github"

interface Repository {
  id: string;
  owner: string;
  name: string;
}

export async function POST(request: NextRequest) {
  try {
    const { repositoryId, repoUrl } = await request.json()
    let owner, repo

    if (repositoryId) {
     
      const repositories = await getRepositoriesFromStorage()
      const repository = repositories.find((r: any) => r.id === repositoryId)

      if (!repository) {
        return NextResponse.json({ error: "Repository not found" }, { status: 404 })
      }

      owner = repository.owner
      repo = repository.name
    } else if (repoUrl) {
      // Extract owner and repo from URL
      const urlParts = repoUrl.replace(/\/$/, "").split("/")
      owner = urlParts[urlParts.length - 2]
      repo = urlParts[urlParts.length - 1]
    } else {
      return NextResponse.json({ error: "Repository URL or ID is required" }, { status: 400 })
    }

    // Fetch open pull requests
    const pullRequests = await fetchPullRequests(owner, repo)

    const reviews = await Promise.all(
      pullRequests.map(async (pr) => {
        // Analyze code changes
        const analysis = await analyzeCode(owner, repo, pr.number)

        // Generate comment for GitHub
        const comment = generateComment(analysis)

        // Post comment to GitHub
        await postCommentToPR(owner, repo, pr.number, comment)

        return {
          title: pr.title,
          prNumber: pr.number,
          prUrl: `https://github.com/${owner}/${repo}/pull/${pr.number}`,
          author: (pr.user as any)?.login || 'Unknown',
          riskLevel: determineRiskLevel(analysis),
          codeQualityScore: calculateQualityScore(analysis),
          riskyFiles: analysis.riskyFiles || [],
          complexFunctions: analysis.complexFunctions || [],
          refactoringSuggestions: analysis.refactoringSuggestions || [],
          summary: analysis.summary,
          commentPosted: comment,
        }
      }),
    )

    // If this was triggered by a repositoryId, store the analysis results
    if (repositoryId) {
      await storeAnalysisResults(repositoryId, reviews)
    }

    return NextResponse.json({ reviews })
  } catch (error) {
    console.error("Error processing review:", error);
    return NextResponse.json({ error: "Failed to process review" }, { status: 500 });
  }
}

async function getRepositoriesFromStorage(): Promise<Repository[]> {
  "use server"
 
  return []
}



// Store analysis results for historical tracking
async function storeAnalysisResults(repositoryId: string, reviews: any[]) {
 
  console.log(`Storing analysis results for repository ${repositoryId}`)
}

function determineRiskLevel(analysis: any) {
  const { complexityScore, testCoverage, securityIssues } = analysis

  if (securityIssues?.length > 2 || complexityScore > 80) {
    return "High"
  } else if (securityIssues?.length > 0 || complexityScore > 50 || testCoverage < 60) {
    return "Medium"
  } else {
    return "Low"
  }
}

function calculateQualityScore(analysis: any) {
  const { complexityScore, testCoverage, codeStyleScore, securityIssues } = analysis

  const securityPenalty = (securityIssues?.length || 0) * 5
  const score = Math.round(100 - complexityScore * 0.3 + testCoverage * 0.4 + codeStyleScore * 0.3 - securityPenalty)

  return Math.max(0, Math.min(100, score))
}

function generateComment(analysis: any) {
  const { summary, complexFunctions, refactoringSuggestions, securityIssues } = analysis

  let comment = `## Automated Code Review\n\n${summary}\n\n`

  if (complexFunctions?.length > 0) {
    comment += "### Complex Functions\n"
    complexFunctions.forEach((func: string) => {
      comment += `- ${func}\n`
    })
    comment += "\n"
  }

  if (refactoringSuggestions?.length > 0) {
    comment += "### Refactoring Suggestions\n"
    refactoringSuggestions.forEach((suggestion: string) => {
      comment += `- ${suggestion}\n`
    })
    comment += "\n"
  }

  if (securityIssues?.length > 0) {
    comment += "### Security Concerns\n"
    securityIssues.forEach((issue: string) => {
      comment += `- ⚠️ ${issue}\n`
    })
    comment += "\n"
  }

  comment += "_This review was automatically generated by PR Review Helper._"

  return comment
}
